# AI Task: TDD Sprint â€“ Build a Complete Feature Using Test-Driven Development

## Objective:
Use Test-Driven Development (TDD) to build a complete file upload feature from scratch with 90%+ test coverage, readable and maintainable code, and passing unit + integration tests.

---

## ðŸ§© Step 1: Feature Selection

**Feature:** File Upload

**Brief Description:**
Allow users to upload files (e.g., PDF, PNG, DOCX) through a REST API endpoint. Files should be saved to the file system (or cloud storage), and metadata (filename, size, type, timestamp) stored in the database.

---

## ðŸ§ª Step 2: Test Generation (Red Phase)

**Prompt:**
> Write a full set of failing unit tests for a file upload feature.

### Requirements:
- Use `pytest` (or `unittest` if preferred) in Python
- Cover:
  - âœ… Successful upload of valid file types
  - âœ… Rejection of unsupported file types
  - âœ… Empty file upload attempt
  - âœ… File size exceeding limit
  - âœ… Duplicate filename handling
  - âœ… Metadata persistence (DB save)
  - âœ… Upload failure handling (e.g., I/O error)
- Use mocks for storage and DB access
- Tests should **initially fail** (TDD Red phase)

### Deliverable:
- âœ… `test_file_upload.py` with 5â€“10 test functions
- âœ… Tests follow proper naming and documentation

---

## âš™ï¸ Step 3: Minimal Implementation (Green Phase)

**Prompt:**
> Implement the minimum code required to make all file upload unit tests pass.

### Requirements:
- Create a `FileUploadService` or similar
- Save the file to `/uploads/` or mock path
- Use in-memory DB or mock repository to store metadata
- Accept only `.pdf`, `.png`, `.docx` (configurable)
- Return upload success/failure response

### Deliverable:
- âœ… `file_upload_service.py` (or equivalent)
- âœ… File save logic + metadata persistence
- âœ… All tests from Step 2 now pass

---

## ðŸ” Step 4: Refactor (Refactor Phase)

**Prompt:**
> Refactor the implementation while keeping all tests green.

### Requirements:
- Extract helper methods (e.g., for validation, filename sanitization)
- Improve naming and folder structure
- Apply SOLID principles (especially SRP)
- Add type hints and docstrings

### Deliverable:
- âœ… Refactored code (e.g., `validators.py`, `models.py`)
- âœ… All tests still pass (100% green state)

---

## ðŸ”— Step 5: Add Integration Tests

**Prompt:**
> Add integration tests for the file upload API.

### Requirements:
- Use FastAPI/Flask/Express/Spring to expose `/upload` endpoint
- Simulate:
  - âœ… Valid file upload end-to-end (HTTP â†’ service â†’ disk â†’ DB)
  - âœ… Invalid file extension (expect 400)
  - âœ… Oversized file (expect 413 or custom error)
- Use mock file system or test folder for upload

### Deliverable:
- âœ… `test_upload_api.py` with 2â€“4 integration tests
- âœ… End-to-end upload scenarios covered

---

## ðŸ“ˆ Step 6: Test Coverage and Quality Check

**Prompt:**
> Measure test coverage and check code quality.

### Checklist:
- âœ… Use `coverage.py` to measure code coverage
- âœ… Ensure **90%+ test coverage**
- âœ… Review:
  - Logging and error handling
  - Config-driven limits (file types, size)
  - Readability and maintainability
- âœ… Create `config.py` or `.env` for max file size, upload dir

---

## âœ… Success Criteria:

- âœ… 90%+ unit and integration test coverage
- âœ… All tests pass (green state)
- âœ… Code is clean, modular, and follows SOLID
- âœ… API handles all edge cases and errors gracefully
- âœ… Documentation/comments exist for public methods

---

# AI Driven Development â€“ #60dayChallenge
Start with **Step 2**: Generate failing unit tests for file upload.
